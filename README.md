# brontosaurus - streamlined JSON APIs

Write small and fast API servers using:
* Sanic - for a fast async http server
* JSON Schema - for request and response validation and documentation
* JSON RPC 2.0 - for a simple surrounding format
* Python - for all your easy to read glue code

Some benefits:
* Automatic request validation
* Autogenerated API documentation in markdown
* Removes various RPC setup boilerplate
* Handles bulk requests asynchronously with no extra code
* Sets default values in requests and responses automatically
* Automatically validates responses during development/test mode
* Handles binary file uploads and responses

It is opinionated but customizable. The APIs are not restful, but instead use
the [JSON RPC 2.0]() standard.

**View a [quick code example](examples/machine-learning)**

## Documentation

### `API()`

Create a new instance of the API object, which can be used to register methods and run the server.

### `api.method(name, summary)`

Register a method name and a short description. Used as a decorator around a function that handles the method.

The function receives the method parameters as a dictionary and the request headers (as a TODO).

```py
@api.method('no_op', 'Does nothing')
def no_op(params, headers):
  pass
```

### `api.params(json_schema: dict)`

Set the JSON Schema for the parameters for a method. Used as a decorator around a method handler function.

```py
# JSON schema for some message
message = {
  'type': 'object',
  'required': ['message'],
  'properties': {
    'message': {
      'type': 'string',
    }
  }
}

@api.method('log', 'Logs something in the backend')
@api.params(message)
def no_op(params, headers):
  logger.info(params)
```

See the [JSON Schema](https://json-schema.org/understanding-json-schema/) guide for detailed information on how to write these schemas.

### `api.result(json_schema: dict)`

Set the JSON Schema for the result for a method, useful for documentation and tests. Used as a decorator around a method handler function.

```py
# JSON schema for the params and the result
echo_message = {
  'type': 'object',
  'required': ['message'],
  'properties': {
    'message': {
      'type': 'string'
    }
  }
}

@api.method('echo', 'Repeat a message back to you')
@api.params(echo_message)
@api.result(echo_message)
def echo(params, headers):
  return {'message': params['message']}
```

### `api.ref(type_name: str, json_schema: dict)`

Register a JSON schema to be displayed in the API documentation. It does not affect the API, and only returns a
plain dict of the schema.

```py
login_schema = api.ref('login', {
  'title': 'Login data',
  'type': 'object',
  'properties': {
    'password': {
      'type': 'string',
      'minLength': 7,
    },
    'email': {
      'type': 'string',
      'format': 'idn-email'
    }
  }
})
```

### `api.run(port=8080, development=True)`

Run the server.

In development mode, the documentation file will be generated. Also, the method
results will be validated against their JSON Schemas (but not in production).

## Development

### Run the tests

Activate a virtual env with something like

```sh
python -m venv env
source env/bin/activate
```

Install dependencies and test dependencies

```sh
pip install -r requirements.txt -r dev-requirements.txt
```

Run the tests

```sh
make test
```

### Contribution
